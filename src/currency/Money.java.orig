package currency;

import java.math.RoundingMode;
import java.text.DecimalFormat;

import currency.exceptions.InvalidMoneyValueException;

public class Money {

    private final int decimalNumber;
    private final int wholeNumber;
    private final boolean hasNegativeValue;
    private final Currency currency;

<<<<<<< HEAD
    public Money(Currency currency, int wholeNumber, int decimalNumber) throws InvalidMoneyValueException {
	if (wholeNumber == 0) {
	    hasNegativeValue = (decimalNumber < 0) ? true : false;
	} else if (wholeNumber < 0) {
	    hasNegativeValue = true;
	} else {
=======
    public Money(Currency currency, int wholeNumber, int decimalNumber)
	    throws InvalidMoneyValueException {
	long sign = wholeNumber * decimalNumber;
	if(sign < 0){
	    throw new InvalidMoneyValueException(" both arguments have non-zero values that are different in sign.");
	} else {
	if(wholeNumber < 0 || decimalNumber < 0){
	    hasNegativeValue = true;
	} else { 
>>>>>>> 303c24de266cb5c2a2287ac9080484cc70b57c22
	    hasNegativeValue = false;
	}
	this.currency = currency;
	this.wholeNumber = wholeNumber;
	this.decimalNumber = decimalNumber;
	}
    }

    public Money multiply(double multiplicand) {
	double productWholeNumber = ((double) wholeNumber) * multiplicand;
	double productDecimal = ((double) decimalNumber) * multiplicand;
	return createMoney(currency, productWholeNumber, productDecimal);
    }

    public Money divide(float dividend) {
	if (dividend == 0) {
	    throw new ArithmeticException("Division by zero.");
	}
	double productWholeNumber = ((double) wholeNumber) / dividend;
	double productDecimal = ((double) decimalNumber) / dividend;
	return createMoney(currency, productWholeNumber, productDecimal);

    }

<<<<<<< HEAD
    // TODO rename this muthafuka
    private static Money abracadabra(Currency currency, double productWholeNumber, double productDecimal) {
	double product = productWholeNumber + (productDecimal / 100);
	StringBuilder sb = new StringBuilder(Double.toString(product));
	int index = sb.indexOf(".");
	index = index + 3;
	if (Integer.parseInt(sb.substring(index, index + 1)) >= 5) {
	    sb.setCharAt(index - 1, Character.forDigit(Integer.parseInt(sb.substring(index - 1, index)) + 1, 10));
	}
	sb.delete(index, sb.length());
=======
    private static Money createMoney(Currency currency,
	    double productWholeNumber, double productDecimal) {
	double result = createDoubleForm(productWholeNumber, productDecimal);
	DecimalFormat doubleRep = new DecimalFormat("0.00");
	doubleRep.setRoundingMode(RoundingMode.HALF_UP);
	String sb = doubleRep.format(result);
	System.out.println(sb);
>>>>>>> 303c24de266cb5c2a2287ac9080484cc70b57c22
	int whole = Integer.parseInt(sb.substring(0, sb.indexOf(".")));
	int decimal = Integer.parseInt(sb.substring(sb.indexOf(".") + 1, sb.length()));
	return new Money(currency, whole, decimal);
    }

<<<<<<< HEAD
    // ////
    // /PUT YOUR ADD/SUBTRACT STUFF HERE
    // ////
    public Money add(Money addend) {
	checkisSameCurrency(addend);
	int wholeNumber = this.wholeNumber + addend.wholeNumber;
	int decimalNumber = this.decimalNumber + addend.decimalNumber;
	if (decimalNumber >= 100) {
	    wholeNumber++;
	    decimalNumber %= 100;
	}
	return new Money(currency, wholeNumber, decimalNumber);
    }

    public void checkisSameCurrency(Money money) {
	if (currency != money.currency) {
	    String message = concatAll("cannot perform operation on ", currency.toString(), " and ", money.currency.toString());
	    throw new IncompatibleCurrencyException(message);
	}
    }

    public Money subtract(Money subtrahend) {
	checkisSameCurrency(subtrahend);
	int wholeNumber = this.wholeNumber - subtrahend.wholeNumber;
	int decimalNumber = this.decimalNumber - subtrahend.decimalNumber;
	if (decimalNumber < 0) {
	    int borrow = 100;
	    if (this.decimalNumber < 10)
		borrow = 10;
	    wholeNumber--;
	    decimalNumber = Math.abs(decimalNumber + borrow);
	}
	return new Money(currency, wholeNumber, decimalNumber);
    }

    private static String concatAll(String... strings) {
=======
    private static double createDoubleForm(double productWholeNumber,
	    double productDecimal) {
	return productWholeNumber + (productDecimal / 100);
    }

    //ADD-SUBTRACT
    
    
    
    
    
    private static StringBuilder concatAll(String... strings) {
>>>>>>> 303c24de266cb5c2a2287ac9080484cc70b57c22
	StringBuilder newString = new StringBuilder();
	for (String s : strings) {
	    newString.append(s);
	}
	return newString;
    }

    public String getCurrencyType() {
	return currency.toString();
    }

<<<<<<< HEAD
    public BigDecimal getValue() {
	String valueString = concatAll(Integer.toString(wholeNumber), ".", Integer.toString(decimalNumber));
	BigDecimal bd = new BigDecimal(valueString);
	return bd;
=======
    public String getValue() {
	StringBuilder value = concatAll(Integer.toString(wholeNumber), ".",
		Integer.toString(decimalNumber));
	if (decimalNumber < 10) {
	    value.insert(value.indexOf(".") + 1, '0');
	}
	return value.toString();
>>>>>>> 303c24de266cb5c2a2287ac9080484cc70b57c22
    }

    @Override
    public String toString() {
<<<<<<< HEAD
	String toReturn = concatAll(currency.toString(), " ", Integer.toString(wholeNumber), ".", Integer.toString(decimalNumber));
	return toReturn;
=======
	StringBuilder sb = concatAll(getCurrencyType(), " ", getValue());
	return sb.toString();
>>>>>>> 303c24de266cb5c2a2287ac9080484cc70b57c22
    }

    @Override
    public int hashCode() {
	final int prime = 31;
	int result = 1;
	result = prime * result + ((currency == null) ? 0 : currency.hashCode());
	result = prime * result + decimalNumber;
	result = prime * result + (hasNegativeValue ? 1231 : 1237);
	result = prime * result + wholeNumber;
	return result;
    }

    @Override
    public boolean equals(Object obj) {
	if (this == obj) {
	    return true;
	}
	if (obj == null) {
	    return false;
	}
	if (!(obj instanceof Money)) {
	    return false;
	}
	Money other = (Money) obj;
	if (currency != other.currency) {
	    return false;
	}
	if (decimalNumber != other.decimalNumber) {
	    return false;
	}
	if (hasNegativeValue != other.hasNegativeValue) {
	    return false;
	}
	if (wholeNumber != other.wholeNumber) {
	    return false;
	}
	return true;
    }
}
